<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>第一个博客  测试一下</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="从c到c++1.前情提要①c与c++千丝万缕的联系C是面向过程的编程语言当写大型程序是，过程就会过于复杂 c++的曾用名“c with class”。它是面向对象的语言。在c的基础上修改而成 ②拓展java的原名叫做“c++ - -” 是在使用c++的过程中遇见的一些局限性，对其进行修改而成。 c#是为了和Java竞争产生的，公司不一样 2.头文件c++支持c语言的全部头文件，同时，自己的头文件是">
<meta property="og:type" content="article">
<meta property="og:title" content="第一个博客  测试一下">
<meta property="og:url" content="http://example.com/2023/10/26/%E4%BB%8Ec%E5%88%B0c++/index.html">
<meta property="og:site_name" content="第一个博客  测试一下">
<meta property="og:description" content="从c到c++1.前情提要①c与c++千丝万缕的联系C是面向过程的编程语言当写大型程序是，过程就会过于复杂 c++的曾用名“c with class”。它是面向对象的语言。在c的基础上修改而成 ②拓展java的原名叫做“c++ - -” 是在使用c++的过程中遇见的一些局限性，对其进行修改而成。 c#是为了和Java竞争产生的，公司不一样 2.头文件c++支持c语言的全部头文件，同时，自己的头文件是">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/image-20210130153947983.png">
<meta property="article:published_time" content="2023-10-26T05:12:40.602Z">
<meta property="article:modified_time" content="2023-03-02T04:07:03.022Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/image-20210130153947983.png">
  
    <link rel="alternate" href="/atom.xml" title="第一个博客  测试一下" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">第一个博客  测试一下</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-从c到c++" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/10/26/%E4%BB%8Ec%E5%88%B0c++/" class="article-date">
  <time class="dt-published" datetime="2023-10-26T05:12:40.602Z" itemprop="datePublished">2023-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="从c到c"><a href="#从c到c" class="headerlink" title="从c到c++"></a>从c到c++</h1><h2 id="1-前情提要"><a href="#1-前情提要" class="headerlink" title="1.前情提要"></a>1.前情提要</h2><h3 id="①c与c-千丝万缕的联系"><a href="#①c与c-千丝万缕的联系" class="headerlink" title="①c与c++千丝万缕的联系"></a>①c与c++千丝万缕的联系</h3><p>C是面向过程的编程语言<br>当写大型程序是，过程就会过于复杂</p>
<p>c++的曾用名“c with class”。它是面向对象的语言。<br>在c的基础上修改而成</p>
<h3 id="②拓展"><a href="#②拓展" class="headerlink" title="②拓展"></a>②拓展</h3><p>java的原名叫做“c++ - -” 是在使用c++的过程中遇见的一些局限性，对其进行修改而成。</p>
<p>c#是为了和Java竞争产生的，公司不一样</p>
<h2 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2.头文件"></a>2.头文件</h2><p>c++支持c语言的全部头文件，同时，自己的头文件是在c的头文件基础上去掉“.h”在前面加上c</p>
<table>
<thead>
<tr>
<th align="center">c语言</th>
<th align="center">c++</th>
</tr>
</thead>
<tbody><tr>
<td align="center">stdio.h</td>
<td align="center">iostream</td>
</tr>
<tr>
<td align="center">math.h</td>
<td align="center">cmath</td>
</tr>
<tr>
<td align="center">string.h</td>
<td align="center">cstring</td>
</tr>
<tr>
<td align="center">stdlib.h</td>
<td align="center">cstdlib</td>
</tr>
<tr>
<td align="center">……</td>
<td align="center">……</td>
</tr>
</tbody></table>
<p>[^①]:iostream ——–&gt;input output stream 输入输出流；里面包含了<cstdio> <cmatn> <cstdlib> 。  直接用就好</p>
<h2 id="3-命名空间"><a href="#3-命名空间" class="headerlink" title="3.命名空间"></a>3.命名空间</h2><h3 id="①概念（作用）"><a href="#①概念（作用）" class="headerlink" title="①概念（作用）"></a>①概念（作用）</h3><p>命名空间时ANSIC++引入的可以由用户命名的作用域，用来处理程序中常见的同名冲突。<br>全局变量中不能有同名函数、变量和类<br>为了使同名类存在，就要加作用域，于是就有了命名空间</p>
<p>本质上，命名空间就是定义了一个范围。</p>
<h3 id="②如何使用命名空间"><a href="#②如何使用命名空间" class="headerlink" title="②如何使用命名空间"></a>②如何使用命名空间</h3><h4 id="Ⅰ-定义命名空间"><a href="#Ⅰ-定义命名空间" class="headerlink" title="Ⅰ.定义命名空间"></a>Ⅰ.定义命名空间</h4><p>namespace <name> {代码}</p>
<h4 id="Ⅱ-访问命名空间"><a href="#Ⅱ-访问命名空间" class="headerlink" title="Ⅱ.访问命名空间"></a>Ⅱ.访问命名空间</h4><ol>
<li><p>通过空间名::访问<br>       <em><name><code>::</code>变量、函数……</em></p>
</li>
<li><p>先申明使用的命名空间（当多个命名空间里面的变量同名时，会发生二义性的问题）（一般不用）<br>       <em>using namespace  &lt;名字&gt;</em></p>
</li>
<li><p>申明使用某个命名空间下面的某个变量或函数(变量或函数)<br>   <em>using <name></em></p>
</li>
</ol>
<p>命名空间可以嵌套使用。</p>
<h4 id="Ⅲ-代码展示"><a href="#Ⅲ-代码展示" class="headerlink" title="Ⅲ.代码展示"></a>Ⅲ.代码展示</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义aqua空间</span></span><br><span class="line"><span class="keyword">namespace</span> aqua</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">	<span class="type">char</span> name_1[<span class="number">5</span>]=<span class="string">&quot;aqua&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义hydro空间</span></span><br><span class="line"><span class="keyword">namespace</span> hydro</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">	<span class="type">char</span> name_2[<span class="number">6</span>] = <span class="string">&quot;hydro&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//1、通过空间名::访问</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, aqua::a);  <span class="comment">//6</span></span><br><span class="line">	<span class="comment">//2、先申明使用某个命名空间里面的代码</span></span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> aqua;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> hydro;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s   %s\n&quot;</span>, name_1, name_2);  <span class="comment">//aqua   hydro</span></span><br><span class="line">	<span class="comment">//printf(&quot;%d\n&quot;,a);          //指定不明确，发生二义性问题</span></span><br><span class="line">	<span class="comment">//3、先申明使用某个命名空间下的某个变量或函数</span></span><br><span class="line">	<span class="keyword">using</span> aqua::a;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);  <span class="comment">//6</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="③标准命名空间（std）"><a href="#③标准命名空间（std）" class="headerlink" title="③标准命名空间（std）"></a>③标准命名空间（std）</h3><p><strong>std是什么？</strong></p>
<p>std是个名称空间标示符，C++标准库中的函数或者对象都是在命名空间std中定义的，所以我们要使用标准函数库中的函数或对象都要使用std来限定。</p>
<p>对象cout是标准函数库所提供的对象，而标准库在名字空间中被指定为std，所以在使用cout的时候要加上std: : 。这样编译器就会明白我们调用的cout是名字空间std中的cout。</p>
<p><strong>为什么将cout放到命名空间中？</strong></p>
<p>是因为像cout这样的对象在实际操作中或许会有好几个，比如说你自己也可能会不小心定义了一个对象叫cout，那么这两个cout对象就会产生冲突。</p>
<h2 id="4-输入输出"><a href="#4-输入输出" class="headerlink" title="4.输入输出"></a>4.输入输出</h2><h3 id="①基础讲解"><a href="#①基础讲解" class="headerlink" title="①基础讲解"></a>①基础讲解</h3><p>C++使用一个预定义的全局对象来输入输出<br>在命名空间<code>std</code>下，使用<code>cout</code> <code> cin</code>来输入输出（注意：它不是函数，是对象）</p>
<p>用<code>&lt;&lt;</code>  <code>&gt;&gt;</code> 表示数据的流向。数据从开口端流向尖头端<br>∴ 输出：cout 这个对象就代表黑窗口，数据流向黑窗口即输出。并且它可以自动识别数据类型。(<code>&lt;&lt;</code>)<br>    输入：cin也是如此，代表数据从屏幕流向变量中。（<code>&gt;&gt;</code> ）</p>
<ul>
<li>cin 输入流对象</li>
<li>cout 输出流对象</li>
<li>endl （它也是在std命名空间中）换行，并清空输出缓冲区(end line 结束一行，并另起一行)</li>
<li>\n照样可以在cout中使用</li>
</ul>
<h3 id="②代码展示"><a href="#②代码展示" class="headerlink" title="②代码展示"></a>②代码展示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  <span class="comment">//input output stream </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//避免之后每次使用都加上 std::(方便一点)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//标准输出</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;name:\t&quot;</span> &lt;&lt; <span class="string">&quot;aqua&quot;</span> &lt;&lt; endl;  <span class="comment">//name:   aqua</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;age:\t&quot;</span> &lt;&lt; <span class="number">18</span> &lt;&lt; endl;         <span class="comment">//age:    18</span></span><br><span class="line">	<span class="comment">//标准输入：</span></span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	cin &gt;&gt; name &gt;&gt; age; <span class="comment">//输入数据:aqua 18</span></span><br><span class="line">	cout &lt;&lt; name &lt;&lt;<span class="string">&quot;  &quot;</span> &lt;&lt; age;<span class="comment">//aqua  18</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-基本数据类型"><a href="#5-基本数据类型" class="headerlink" title="5.基本数据类型"></a>5.基本数据类型</h2><p>C++和C语言的基本数据类型几乎一样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> 	<span class="type">short</span> 	<span class="type">int</span>  <span class="type">long</span> <span class="type">long</span>	<span class="type">float</span> 	<span class="type">double</span> 	<span class="type">unsigned</span> 	<span class="type">signed</span> ...</span><br></pre></td></tr></table></figure>

<h3 id="①bool类型"><a href="#①bool类型" class="headerlink" title="①bool类型:"></a>①bool类型:</h3><p>yiC++中原生支持，不需要包含其他头文件，C++直接支持bool类型</p>
<p>布尔类型对象可以被赋予文字值true或false，所对应的关系就是真与假的概念，即1,0。</p>
<p>可以使用<code>boolalpha</code>打印出bool类型的true或false</p>
<p>[^③]:boolalpha 也是std中第一个对象；它和endl 也可以别称之为算子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">	cout &lt;&lt; ok &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line">	cout &lt;&lt; boolalpha &lt;&lt; ok;  <span class="comment">//true</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="②强弱类型"><a href="#②强弱类型" class="headerlink" title="②强弱类型"></a>②强弱类型</h3><ul>
<li>C语言：强类型，弱检查—— 一般就叫做弱类型了</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>* p1 = p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* pn = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span>* pp = pn;</span><br><span class="line"><span class="comment">//无报错，无警告，完美</span></span><br></pre></td></tr></table></figure>

<p>在C语言中，void*可以和其他类型指针相互转换！</p>
<ul>
<li>C++：强类型，强检查   ——  真正意义上的强类型<br>注意：C++运用指针的时候，会进行强检查，指针类型不一样一定会报错。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>* p1 = p;		<span class="comment">//错误	“初始化”: 无法从“void *”转换为“int *”</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* pn = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span>* pp = pn;		<span class="comment">//正确	任意类型的指针都可以自动转为万能指针</span></span><br></pre></td></tr></table></figure>

<p>在C++中，void*不能直接转换为其他类型的指针，但是可以把其他类型的指针转为void*</p>
<h3 id="③NULL-nullptr"><a href="#③NULL-nullptr" class="headerlink" title="③NULL   nullptr"></a>③NULL   nullptr</h3><p>NULL属于 C 语言中的宏，后来 C++11 引入了 nullptr 关键字，都用来表示空指针。</p>
<p>在 C 语言中，NULL是一个宏，被定义为空指针；在C++中，被定义为0，定义形式如下所示：</p>
<blockquote>
<p>在C语言中NULL会被定义成(void*)NULL，但是C++不允许直接将 void * 隐式转换到其他类型，NULL 只好被定义为 0。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">    #define NULL <span class="number">0</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    #define <span class="title function_">NULL</span> <span class="params">((<span class="keyword">void</span> *)</span><span class="number">0</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>我们来看一个C++中使用NULL的例子，代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; __FUNCSIG__&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* px)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; __FUNCSIG__ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//都调用的整数版本的func函数</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="number">2</span>);			<span class="comment">//void __cdecl func(int)</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="literal">NULL</span>);			<span class="comment">//void __cdecl func(int)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从运行结果来看，无论是数字还是NULL都是调用的，参数为int类型的函数，这是毋庸置疑的，C++中NULL就是0。</p>
<p>但是这个结果更本不符合语义，我们传NULL，肯定是想传一个空指针进去的，而不是作为一个整数0，为此C++11引入了新的空指针关键字。</p>
<p>下面我们来修改一下上面的程序，将 NULL 替换为 nullptr，修改后如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">2</span>);			<span class="comment">//void __cdecl func(int)</span></span><br><span class="line">	<span class="built_in">func</span>(<span class="literal">nullptr</span>);		<span class="comment">//void __cdecl func(char *)</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改之后，运行结果正常！</p>
<p>看到这里你应该明白为什么 C++11 引入 nullptr 了吧！就是因为 NULL 在 C++ 程序中容易引起歧义！</p>
<h3 id="④const"><a href="#④const" class="headerlink" title="④const"></a>④const</h3><h4 id="Ⅰ-C语言"><a href="#Ⅰ-C语言" class="headerlink" title="Ⅰ .C语言"></a>Ⅰ .C语言</h4><p>C语言中，并没有真正的const，它本质上还是一个只读变量，并不是常量</p>
<p>佐证：</p>
<ul>
<li>可以间接通过指针来修改其值</li>
<li>并不能作为数组的大小（定义数组时）</li>
</ul>
<p>通过指针间接修改只读变量的值:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pt = (<span class="type">int</span>*)&amp;num;</span><br><span class="line">*pt = <span class="number">19</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, num,*pt);		<span class="comment">//output:19 19</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> num = <span class="number">18</span>;</span><br><span class="line"><span class="comment">//num = 19			//error:不能修改const 对象</span></span><br><span class="line"><span class="comment">//int arr[num]		//error:数组大小必须是常量</span></span><br></pre></td></tr></table></figure>

<h4 id="Ⅱ-C"><a href="#Ⅱ-C" class="headerlink" title="Ⅱ.C++"></a>Ⅱ.C++</h4><p>C++中的const并不能通过指针修改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* pt = (<span class="type">int</span>*)&amp;num;</span><br><span class="line">*pt = <span class="number">19</span>;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *pt &lt;&lt; endl;		<span class="comment">//output:18 19</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>明明已经通过指针修改了a值，为什么输出却没有变呢？</p>
</li>
<li><p><strong>解释</strong>：<br>C++编译器当碰见常量声明时，在符号表中放入常量，那么如何解释取地址呢？(编译期间即可确定)<br>编译过程中若发现对const使用了&amp;操作符，则给对应的常量分配存储空间（为了兼容C）</p>
<p><img src="/image-20210130153947983.png" alt="image-20210130153947983"></p>
</li>
</ul>
<blockquote>
<p>常量存储在全局区，定义一个指针指向它，当修改指针指向的值时，这个指针会悄悄的给你在栈区开辟一块空间，并在那一块空间存储上你修改的值。但你并不能查看那块新空间的地址（指针任会显示全局区常量的地址）。</p>
</blockquote>
<p><strong>const 的奇葩情况</strong></p>
<p>当给C++中的常量赋值一个变量时，它又变得和C语言一样了；(在程序运行期间分配内存)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = num;					<span class="comment">//赋值变量</span></span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)&amp;a;</span><br><span class="line">*p = <span class="number">21</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *p &lt;&lt; endl;	  <span class="comment">//output:21 21</span></span><br></pre></td></tr></table></figure>

<h4 id="Ⅲ-const字符指针"><a href="#Ⅲ-const字符指针" class="headerlink" title="Ⅲ.const字符指针"></a>Ⅲ.const字符指针</h4><p>C语言中，将一个常量（全局区）赋值给字符指针，会自动默认为这是一个常量字符指针。但C++中不能这样操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* name = <span class="string">&quot;aqua&quot;</span>;		<span class="comment">//错误（在C语言中这是可以通过的写法）</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name =<span class="string">&quot;aqua&quot;</span>;	<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数为字符指针的时候需要特别注意</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> <span class="comment">// 需改成：void show(const char* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">show</span>(<span class="string">&quot;aqua&quot;</span>);	<span class="comment">//&quot;const char *&quot; 类型的实参与 &quot;char *&quot; 类型的形参不兼容</span></span><br><span class="line">	<span class="comment">//void show(const char* name);	//请把函数原型里的参数加上const</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-变量的初始化"><a href="#6-变量的初始化" class="headerlink" title="6.变量的初始化"></a>6.变量的初始化</h2><p>C++中<strong>初始化</strong>和<strong>赋值</strong>并不是同一个概念</p>
<p><strong>初始化</strong>：创建变量时候赋予其一个初始值。</p>
<p><strong>赋值</strong>：把对象（已经创建）的当前值擦除，而用一个新值来代替。</p>
<h3 id="①列表初始化"><a href="#①列表初始化" class="headerlink" title="①列表初始化"></a>①列表初始化</h3><p>使用{}初始化。<br>使用{}初始化变量的好处是：基本上所有对象都可以用{}初始化，提供了统一的初始化方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">5</span>;<span class="comment">//(常规操作)</span></span><br><span class="line">	<span class="type">int</span> a1&#123; <span class="number">3</span> &#125;;<span class="comment">//C++</span></span><br><span class="line">	<span class="type">int</span> b&#123; <span class="number">3.14</span> &#125;;<span class="comment">//不同在于：使用这种写法，精度收缩时会直接报错</span></span><br><span class="line">	<span class="type">int</span> num[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="②直接初始化"><a href="#②直接初始化" class="headerlink" title="②直接初始化"></a>②直接初始化</h3><p>使用()进行初始化。(不建议用这种方式初始化)<br>局限性：初始化数组是不能使用()来初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a1（<span class="number">3</span>）;</span><br><span class="line">	<span class="comment">//int num[3]( 1,2,3 );</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-动态内存分配"><a href="#7-动态内存分配" class="headerlink" title="7.动态内存分配"></a>7.动态内存分配</h2><h3 id="①基本应用"><a href="#①基本应用" class="headerlink" title="①基本应用"></a>①基本应用</h3><p>C语言中是利用库函数malloc和free来分配和释放函数<br>C++提供了运算符new和delete来代替malloc和free。</p>
<p><strong>malloc</strong>的职责仅仅是分配内存，<strong>new</strong>除了分配内存外，还干一件事，调用构造函数。</p>
<p><strong>free</strong>的职责仅仅是释放内存，<strong>delete</strong>除了释放内存之外，还干一件事，调用析构函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//No.1申请普通的变量</span></span><br><span class="line">	<span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//C的方式</span></span><br><span class="line">	<span class="comment">//int* p1 = new int; //不会自动初始化内存</span></span><br><span class="line">	<span class="type">int</span>* p1 = <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">66</span> &#125;<span class="comment">//new:加上&#123;&#125;初始化内存;</span></span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//释放内存</span></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">delete</span> p1;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//No.2申请数组</span></span><br><span class="line">	<span class="comment">//int* parr = new int[5];</span></span><br><span class="line">    <span class="type">int</span>* parr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;<span class="number">0</span>&#125;;<span class="comment">//并全部初始化为0；</span></span><br><span class="line">	 <span class="comment">//释放数组</span></span><br><span class="line">	 <span class="comment">//delete[] parr; //释放不完全</span></span><br><span class="line">  <span class="keyword">delete</span>[] parr;  <span class="comment">//只有这样才能全部的释放数组</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="②定位放置"><a href="#②定位放置" class="headerlink" title="②定位放置"></a>②定位放置</h3><p>一般来说，使用new申请空间时，是从系统的“堆”（heap）中分配空间。申请所得的空间的位置时根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在程序员指定的特定内存创建对象，这就是所谓的“定位放置new”（placement new）操作。</p>
<p>定位放置new操作的语法形式不同于普通的new操作。例如，一般都用如下语句A* p&#x3D;new A;申请空间，而定位放置new操作则使用如下语句A* p&#x3D;new (ptr) A;申请空间，其中ptr就是程序员指定的内存首地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定位放置。</span></span><br><span class="line">	 <span class="type">char</span> memorys[<span class="number">1024</span>];</span><br><span class="line">	 <span class="comment">/*模拟定位放置</span></span><br><span class="line"><span class="comment">	 int* paqua = (int*)memorys;  //后面写的所有，都存储在memorys这段内存中</span></span><br><span class="line"><span class="comment">	 *paqua = 90;</span></span><br><span class="line"><span class="comment">	 cout &lt;&lt; *paqua&lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	 char* pname = memorys + 4;</span></span><br><span class="line"><span class="comment">	 strcpy(pname, &quot;aqua&quot;);</span></span><br><span class="line"><span class="comment">	 cout &lt;&lt; pname&lt;&lt;endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 cout &lt;&lt; memorys &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">     <span class="comment">//C++new实现</span></span><br><span class="line">	 <span class="type">int</span>* paqua = <span class="built_in">new</span>(memorys)<span class="type">int</span>&#123; <span class="number">90</span> &#125;;</span><br><span class="line">	 cout &lt;&lt; *paqua &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	 <span class="type">char</span>* pname = <span class="built_in">new</span>(memorys + <span class="number">4</span>)<span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">	 <span class="built_in">strcpy</span>(pname, <span class="string">&quot;aquahydro&quot;</span>);</span><br><span class="line">	 cout &lt;&lt; memorys + <span class="number">4</span> &lt;&lt; endl;</span><br><span class="line">	 cout &lt;&lt; pname &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、三目运算符"><a href="#8、三目运算符" class="headerlink" title="8、三目运算符"></a>8、三目运算符</h2><p>C++中，三目运算符返回的是<strong>变量本身</strong>，而不是值。<br>C语言中。三目运算符返回的是一个值。（<strong>常量</strong>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">	cout &lt;&lt; (a &gt; b ? a : b) &lt;&lt; endl;  <span class="comment">//3</span></span><br><span class="line">	(a &gt; b ? a : b) = <span class="number">99</span>;<span class="comment">//这种操作在C语言中是不被允许的。报错：左操作数必须是左值。</span></span><br><span class="line">	cout &lt;&lt; (a &gt; b ? a : b) &lt;&lt; endl;  <span class="comment">//99    //直接对三目运算符返回的变量b进行了赋值</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;        <span class="comment">//a:2</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;       <span class="comment">//b:99</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9、引用"><a href="#9、引用" class="headerlink" title="9、引用"></a>9、引用</h2><h3 id="①什么是引用"><a href="#①什么是引用" class="headerlink" title="①什么是引用"></a>①什么是引用</h3><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称来操作变量。对引用的操作与对其所绑定的变量或对象的操作完全等价。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type &amp;refName = variable_name;</span><br></pre></td></tr></table></figure>

<h3 id="②普通引用（-）"><a href="#②普通引用（-）" class="headerlink" title="②普通引用（&amp;）"></a>②普通引用（&amp;）</h3><p>只能引用左值，可以修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//引用是一种特殊的数据类型（和指针类似），用来给对想取别名</span></span><br><span class="line"><span class="comment">//如何定义引用</span></span><br><span class="line">	<span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line">	<span class="type">int</span>&amp; rage = age;<span class="comment">//这是定义了一个引用，引用了age对象</span></span><br><span class="line">	cout &lt;&lt; age &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; rage &lt;&lt; endl;  <span class="comment">//18   18</span></span><br><span class="line">	cout &lt;&lt; &amp;age &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; &amp;rage &lt;&lt; endl;  <span class="comment">//地址是相同的：表明本质上就是同一个东西</span></span><br><span class="line">	age = <span class="number">88</span>;</span><br><span class="line">	cout &lt;&lt; age &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; rage &lt;&lt; endl;    <span class="comment">//88   88</span></span><br><span class="line">	cout &lt;&lt; &amp;age &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; &amp;rage &lt;&lt; endl;  <span class="comment">//4个地址都是一样的</span></span><br><span class="line"><span class="comment">//只能引用左值（变量）</span></span><br><span class="line">  <span class="type">int</span>&amp; ra = <span class="number">88</span>;<span class="comment">//错误的写法</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="③常引用（const-xxx-）"><a href="#③常引用（const-xxx-）" class="headerlink" title="③常引用（const xxx &amp;）"></a>③常引用（const xxx &amp;）</h3><p>可左可右，不能修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//2、定义函数参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//常引用，不可通过引用修改其值。用在函数形参中，对于函数里面不需要修改的实参，都可以声明为常引用</span></span><br><span class="line"><span class="comment">//定义常引用	</span></span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; ra = <span class="number">88</span>;</span><br><span class="line"><span class="comment">//1、不可修改</span></span><br><span class="line">	ra=<span class="number">66</span>;<span class="comment">//错误</span></span><br><span class="line"><span class="comment">//2、定义函数参数</span></span><br><span class="line">	<span class="built_in">foo</span>(ra);</span><br><span class="line">	<span class="built_in">foo</span>(<span class="number">88</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="④右值引用（-）"><a href="#④右值引用（-）" class="headerlink" title="④右值引用（&amp;&amp;）"></a>④右值引用（&amp;&amp;）</h3><p>可左可右，可以修改。但是伴随着移动语义：资源权限的转移的问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//右值引用（&amp;&amp;）:可左可右，还能修改</span></span><br><span class="line">	<span class="type">int</span>&amp;&amp; ra = <span class="number">6</span>;</span><br><span class="line">	cout &lt;&lt; ra &lt;&lt; endl;  <span class="comment">//6</span></span><br><span class="line">	ra = <span class="number">66</span>;</span><br><span class="line">	cout &lt;&lt; ra &lt;&lt; endl;   <span class="comment">//66</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="⑤注意事项"><a href="#⑤注意事项" class="headerlink" title="⑤注意事项"></a>⑤注意事项</h3><ul>
<li>引用必须初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; refa;		<span class="comment">//错误 没有初始化</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>&amp; refa = a;	<span class="comment">//正确 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>一旦引用被初始化为一个对象，就不能被指向到另一个对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">8</span>,b = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span>&amp; refa = a;</span><br><span class="line">refa = b;		<span class="comment">//只是把b的值赋值给了refa，而不是让refa引用b</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果要引用右值，那么必须使用常量引用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; refc = <span class="number">12</span>;		<span class="comment">//错误 “初始化”: 无法从“int”转换为“int &amp;”，非常量引用的初始值必须为左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;refc =<span class="number">12</span>;	<span class="comment">//正确 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>当然，也可以使用右值引用来引用常量；或者使用std::move()把左值转成右值</p>
<ul>
<li><p>引用右值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; refr = <span class="number">21</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用经过std::move()转换过的变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; refr = <span class="number">21</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>常引用和右值引用有什么区别呢？</strong></p>
<p>1，常引用引用的值是不可以修改的；但是右值引用引用的值是可以修改的！(大多数情况用常引用：函数参数)</p>
<p>2，右值引用一般用来实现移动语义（资源权限的转移）</p>
</li>
<li><p>通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护</p>
</li>
</ul>
<h3 id="⑥引用的用处"><a href="#⑥引用的用处" class="headerlink" title="⑥引用的用处"></a>⑥引用的用处</h3><ul>
<li>作为函数参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在函数内部改变实参的值需要传变量的地址</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>* n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*n=<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针是非常危险的，因为指针所指向的内存空间，不确定，需要额外判断</span></span><br><span class="line"><span class="built_in">fun</span>(<span class="literal">nullptr</span>);	<span class="comment">//传nullptr 会发生中断，当然，你可以在函数里面判断是否是空，但是如果是野指针呢？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在C++中，除了使用指针外，还可以通过引用来达到这个目的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以用指针的引用替代二级指针</span></span><br></pre></td></tr></table></figure>

<ul>
<li>作为函数返回值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> age = <span class="number">18</span>;</span><br><span class="line">	<span class="keyword">return</span> age;		<span class="comment">//注意：不要返回局部变量的引用或地址，可以使用静态变量或全局变量替代</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>&amp; refAge = <span class="built_in">getAge</span>();</span><br><span class="line">refAge = <span class="number">23</span>;</span><br></pre></td></tr></table></figure>

<h3 id="⑦引用的本质"><a href="#⑦引用的本质" class="headerlink" title="⑦引用的本质"></a>⑦引用的本质</h3><p>引用如此神奇，那么引用的本质到底是什么呢？</p>
<ul>
<li>引用在C++中，内部实现是一个常指针：type &amp;name &lt;&#x3D;&#x3D;&gt; type*const name</li>
<li>C++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同。</li>
<li>从使用的角度，引用会让人误会其只是一个别名，没有自己的存储空间。这是C++为了实用性而做出的细节隐藏(所以我们查看不了引用的地址)</li>
</ul>
<h2 id="10、枚举类型"><a href="#10、枚举类型" class="headerlink" title="10、枚举类型"></a>10、枚举类型</h2><p>C语言和C++语言都提供了枚举类型，两者是有一定区别。</p>
<p><code>有如下定义：</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SHAPE</span> &#123;CIRCLE,RECT,LINE,POINT&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">WEEK</span>  &#123;MON,TUE,WED,THI,FIR,SAT,SUN&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="①C语言中的enum"><a href="#①C语言中的enum" class="headerlink" title="①C语言中的enum"></a>①C语言中的enum</h3><ul>
<li><p>允许非枚举值赋值给枚举类型，允许其他枚举类型的值赋值给另一个枚举类型</p>
<p>enum WEEK today &#x3D; 3;	&#x2F;&#x2F;正确<br>today &#x3D; CIRCLE;			&#x2F;&#x2F;正确</p>
</li>
<li><p>枚举具有外层作用域，容易造成名字冲突<code>(在不同作用域不会冲突，但是遵循就近原则，访问不到外层作用域的枚举)</code></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">OTHER</span> &#123; RECT &#125;;<span class="comment">//error C2365: “RECT”: 重定义；以前的定义是“枚举数”</span></span><br><span class="line"><span class="type">int</span> RECT = <span class="number">12</span>;		<span class="comment">//同上</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不同类型的枚举值可以直接比较</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CIRCLE == MON)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;oh.yes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="②C-中的enum"><a href="#②C-中的enum" class="headerlink" title="②C++中的enum"></a>②C++中的enum</h3><ul>
<li>只允许赋值枚举值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WEEK</span> <span class="title">today</span> =</span> <span class="number">3</span>;	<span class="comment">//错误	error C2440: “初始化”: 无法从“int”转换为“main::WEEK”</span></span><br><span class="line">today = CIRCLE;			<span class="comment">//错误	error C2440: “=”: 无法从“main::SHAPE”转换为“main::WEEK”</span></span><br></pre></td></tr></table></figure>

<ul>
<li>枚举元素会暴露在外部作用域，不同两个枚举类型，若含有相同枚举元素，则会冲突</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">OTHER</span> &#123; RECT &#125;;	<span class="comment">//错误 	error C2365: “RECT”: 重定义；以前的定义是“枚举数”</span></span><br><span class="line"><span class="type">int</span> RECT = <span class="number">12</span>;			<span class="comment">//错误同上	但是可以通过枚举名访问指定的枚举属性</span></span><br><span class="line">OTHER::RECT;			<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不同类型的枚举也可以直接比较</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (CIRCLE == MON)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;oh.yes&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="③C-中的-enum-class-强枚举类型"><a href="#③C-中的-enum-class-强枚举类型" class="headerlink" title="③C++中的 enum class 强枚举类型"></a>③C++中的 enum class 强枚举类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">SHAPE</span> &#123;CIRCLE,RECT,LINE,POINT&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">WEEK</span>  &#123;MON,TUE,WED,THI,FIR,SAT,SUN&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>强枚举类型不会将枚举元素暴露在外部作用域，必须通过枚举名去访问</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;SHAPCE::RECT&lt;&lt;endl;	<span class="comment">//输出 1 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>不相关的两个枚举类型不能直接比较，编译报错</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SHAPE::CIRCLE == WEEK::MON)	<span class="comment">//error C2676: 二进制“==”:“main::SHAPE”不定义该运算符或到预定义运算符可接收的类型的转换</span></span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;oh.yes&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="④小结"><a href="#④小结" class="headerlink" title="④小结"></a><strong>④小结</strong></h3><ul>
<li><p>C 枚举类型支持不同类型枚举值之间赋值、以及数字赋值、比较，并且具有外层作用域。</p>
</li>
<li><p>C++ 中枚举不允许不同类型的值给枚举类型变量赋值，但仍然支持不同类型之间枚举进行比较，枚举符号常量具有外层作用域。</p>
</li>
<li><p>C++ 强枚举类型不允许不同类型之间的赋值、比较，枚举常量值并不具有外层作用域。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Week</span></span><br><span class="line">&#123;</span><br><span class="line">	mon=<span class="number">1</span>, tus, wes,fur,fri,sta,sun<span class="comment">//乱写的英文，不具有任何具体含义</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//新增的枚举类   </span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">type</span></span><br><span class="line">&#123;</span><br><span class="line">	woman,</span><br><span class="line">	man,</span><br><span class="line">	child</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义枚举变量</span></span><br><span class="line">	Week today = fur;<span class="comment">//和C不同的是可以直接定义，不用取别名(typedef)。</span></span><br><span class="line">	<span class="comment">//Week tom = 5;//错误：初始化无法从int 转为Week；但是在C语言中可以。</span></span><br><span class="line">	Week tom = <span class="built_in">Week</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//使用枚举值（enum）</span></span><br><span class="line">	mon;<span class="comment">//1、直接使用枚举值</span></span><br><span class="line">	Week::mon;<span class="comment">//2、通过枚举类型::使用枚举值</span></span><br><span class="line"><span class="comment">//使用枚举值（enum class）</span></span><br><span class="line">	type::child;   <span class="comment">//只能使用这种方式</span></span><br><span class="line">	child;  <span class="comment">//错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11、auto自动类型推导"><a href="#11、auto自动类型推导" class="headerlink" title="11、auto自动类型推导"></a>11、auto自动类型推导</h2><p>在 C++11 之前的版本中，定义变量或者声明变量之前都必须指明它的类型，比如 int、char 等；但是在一些比较灵活的语言中，比如 JavaScript、PHP、Python 等，程序员在定义变量时可以不指明具体的类型，而是让编译器（或者解释器）自己去推导，这就让代码的编写更加方便。</p>
<p>C++11 为了顺应这种趋势也开始支持自动类型推导了！C++11 使用 auto 关键字来支持自动类型推导。</p>
<p>注意：auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。</p>
<ul>
<li>使用 auto 类型推导的变量必须马上初始化</li>
<li>auto 不能在函数的参数中使用(但是能作为函数的返回值)</li>
<li>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中</li>
<li>auto 关键字不能定义数组</li>
<li>auto 不能作用于模板参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">()</span>   <span class="comment">//auto定义的函数必须写在前面</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="type">double</span> d = <span class="number">5.12</span>;</span><br><span class="line"><span class="comment">//自动类型推导：帮助你判断该定义成什么类型。</span></span><br><span class="line">	<span class="comment">//使用auto定义对象，必须赋值</span></span><br><span class="line">	<span class="keyword">auto</span> a1 = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">auto</span> d1 = <span class="number">3.14</span>;</span><br><span class="line">	<span class="keyword">auto</span> name = <span class="string">&quot;aqua&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">foo</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12、for循环"><a href="#12、for循环" class="headerlink" title="12、for循环"></a>12、for循环</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> nums[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">//1、常规的for循环</span></span><br><span class="line"><span class="comment">//2、基于范围的for循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> n : nums)<span class="comment">//(int n （改成auto n也行更方便）)是数组中元素的类型；相当于把数组中的值逐一赋值给n</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; n &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;  <span class="comment">//1  2  3  4  5</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span>&amp;n : nums)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; n+<span class="number">1</span> &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;  <span class="comment">//2  3  4  5  6</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>从数组的第一个元素开始，逐个赋值给迭代变量</li>
<li>不依赖于下标元素，通用</li>
</ul>
<h2 id="13、类型信息"><a href="#13、类型信息" class="headerlink" title="13、类型信息"></a>13、类型信息</h2><p>typeid 运算符用来获取一个表达式的类型信息。</p>
<p><code>typeid 的操作对象既可以是表达式，也可以是数据类型，下面是它的两种使用方法：</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">typeid</span>( dataType )</span><br><span class="line"><span class="built_in">typeid</span>( expression )</span><br></pre></td></tr></table></figure>

<p>dataType 是数据类型，expression 是表达式，这和 sizeof 运算符非常类似，只不过 sizeof 有时候可以省略括号<code>( )</code>，而 typeid 必须带上括号。</p>
<p>typeid 会把获取到的类型信息保存到一个 type_info 类型的对象里面，并返回该对象的常引用；当需要具体的类型信息时，可以通过成员函数来提取。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个普通变量的类型信息</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> type_info&amp; nInfo = <span class="built_in">typeid</span>(n);</span><br><span class="line">cout &lt;&lt; nInfo.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; nInfo.<span class="built_in">raw_name</span>() &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; nInfo.<span class="built_in">hash_code</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个字面量的类型信息</span></span><br><span class="line"><span class="type">const</span> type_info&amp; dInfo = <span class="built_in">typeid</span>(<span class="number">25.65</span>);</span><br><span class="line">cout &lt;&lt; dInfo.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; dInfo.<span class="built_in">raw_name</span>() &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; dInfo.<span class="built_in">hash_code</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个普通类型的类型信息</span></span><br><span class="line"><span class="type">const</span> type_info&amp; charInfo = <span class="built_in">typeid</span>(<span class="type">char</span>);</span><br><span class="line">cout &lt;&lt; charInfo.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; charInfo.<span class="built_in">raw_name</span>() &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; charInfo.<span class="built_in">hash_code</span>() &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//获取一个表达式的类型信息</span></span><br><span class="line"><span class="type">const</span> type_info&amp; expInfo = <span class="built_in">typeid</span>(<span class="number">20</span> * <span class="number">45</span> / <span class="number">4.5</span>);</span><br><span class="line">cout &lt;&lt; expInfo.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; expInfo.<span class="built_in">raw_name</span>() &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; expInfo.<span class="built_in">hash_code</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>本例中还用到了 type_info 类的几个成员函数，下面是对它们的介绍：</p>
<ul>
<li>name() 用来返回类型的名称。</li>
<li>raw_name() 用来返回名字编码（Name Mangling）算法产生的新名称。。</li>
<li>hash_code() 用来返回当前类型对应的 hash 值。hash 值是一个可以用来标志当前类型的整数，有点类似学生的学号、公民的身份证号、银行卡号等。不过 hash 值有赖于编译器的实现，在不同的编译器下可能会有不同的整数，但它们都能唯一地标识某个类型。</li>
</ul>
<p><strong>除此之外，还可以用 &#x3D;&#x3D; 比较两个类型是否相等</strong></p>
<p>如有以下定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str;</span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f;</span><br></pre></td></tr></table></figure>

<p>类型判断结果为：</p>
<table>
<thead>
<tr>
<th>类型比较</th>
<th>结果</th>
<th>类型比较</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>typeid(int) &#x3D;&#x3D; typeid(int)</td>
<td>true</td>
<td>typeid(int) &#x3D;&#x3D; typeid(char)</td>
<td>false</td>
</tr>
<tr>
<td>typeid(char*) &#x3D;&#x3D; typeid(char)</td>
<td>false</td>
<td>typeid(str) &#x3D;&#x3D; typeid(char*)</td>
<td>true</td>
</tr>
<tr>
<td>typeid(a) &#x3D;&#x3D; typeid(int)</td>
<td>true</td>
<td>typeid(b) &#x3D;&#x3D; typeid(int)</td>
<td>true</td>
</tr>
<tr>
<td>typeid(a) &#x3D;&#x3D; typeid(a)</td>
<td>true</td>
<td>typeid(a) &#x3D;&#x3D; typeid(b)</td>
<td>true</td>
</tr>
<tr>
<td>typeid(a) &#x3D;&#x3D; typeid(f)</td>
<td>false</td>
<td>typeid(a&#x2F;b) &#x3D;&#x3D; typeid(int)</td>
<td>true</td>
</tr>
</tbody></table>
<h2 id="13、函数"><a href="#13、函数" class="headerlink" title="13、函数"></a>13、函数</h2><h3 id="①内联函数"><a href="#①内联函数" class="headerlink" title="①内联函数"></a>①内联函数</h3><p>函数调用时，需要跳转到函数的地址去执行，执行完成后返回到被调用函数，比较费时，因此，C++中提供了一种操作方式，允许编译时直接把函数替换到调用处，即内联函数。在函数前面加上<strong>inline</strong>申明为内联函数。</p>
<p><strong>为什么使用内联函数？</strong><br>内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)</p>
<p><strong>注意：</strong></p>
<ul>
<li>内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求。</li>
<li>C++编译器不一定准许函数的内联请求！(只是对编译器的请求，因此编译器可以拒绝)</li>
<li>现代C++编译器能够进行编译优化，因此一些函数即使没有inline声明，也可能被编译器内联编译<br><strong>C++中内联函数的限制：</strong><ul>
<li>不能存在任何形式的循环语句 </li>
<li>不能存在过多的条件判断语句</li>
<li>函数体不能过于庞大</li>
<li>不能对函数进行取址操作</li>
<li>编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时压栈，跳转和返回的开销。因此，当函数体的执行开销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">include&lt;iostream&gt;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> m_min(a,b) a&gt;b?a:b<span class="comment">//(宏替换)</span></span></span><br><span class="line"><span class="comment">//内联函数（其实不用自己特意写，C++会帮你的）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">f_min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">m_min</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//宏替换：这也算是内敛的过程，直接替换了后面的判断语句</span></span><br><span class="line">	<span class="built_in">f_min</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="②函数默认参数"><a href="#②函数默认参数" class="headerlink" title="②函数默认参数"></a>②函数默认参数</h3><p>定义函数时可以给形参指定一个默认的值，这样调用函数时如果没有给这个形参赋值（没有对应的实参），那么就使用这个默认的值。也就是说，调用函数时可以省略有默认值的参数。如果用户指定了参数的值，那么就使用用户指定的值，否则使用参数的默认值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//可以在定义函数的时候，给定形参一个默认值</span></span><br><span class="line"><span class="comment">//调用者如果没有传递参数，就会使用默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> num=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; num&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果有多个参数时，默认值必须从右往左依次指定（一旦某个参数有默认参数,那么它后面的所有参数都必须有默认参数）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c=<span class="number">7</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">show</span>(<span class="number">22</span>);</span><br><span class="line">	<span class="built_in">show</span>();</span><br><span class="line">	<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="③占位参数"><a href="#③占位参数" class="headerlink" title="③占位参数"></a>③占位参数</h3><p>定义函数时，还可以给函数提供占位参数</p>
<ul>
<li>占位参数只有参数类型，而没有参数名</li>
<li>在函数体内部无法使用占位参数</li>
<li>占位参数也可以指定默认参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>本人认为：占位参数没什么用，唯一的用处就是占一个坑，为以后的函数扩充留下线索。</p>
<h3 id="④函数重载"><a href="#④函数重载" class="headerlink" title="④函数重载"></a>④函数重载</h3><h4 id="Ⅰ基本应用"><a href="#Ⅰ基本应用" class="headerlink" title="Ⅰ基本应用"></a>Ⅰ基本应用</h4><p>函数重载是指在同一作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数。</p>
<p>重载函数通常用来命名一组功能相似的函数。调用函数时，编译器会根据你后面参数的类型，自动为你识别调用哪个函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义一系列的函数来实现交换</span></span><br><span class="line"><span class="keyword">namespace</span> 常规</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">int_swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> t = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">double_swap</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">double</span> t = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">string_swap</span><span class="params">(<span class="type">char</span>* a, <span class="type">char</span>* b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">char</span>* t = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(a)];</span><br><span class="line">		<span class="built_in">strcpy</span>(t, a);</span><br><span class="line">		<span class="built_in">strcpy</span>(a, b);</span><br><span class="line">		<span class="built_in">strcpy</span>(b, t);</span><br><span class="line">		<span class="keyword">delete</span>[] t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接构成重载</span></span><br><span class="line"><span class="type">void</span> _swap(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _swap(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> t = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">char</span>* a, <span class="type">char</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* t = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(a)];</span><br><span class="line">	<span class="built_in">strcpy</span>(t, a);</span><br><span class="line">	<span class="built_in">strcpy</span>(a, b);</span><br><span class="line">	<span class="built_in">strcpy</span>(b, t);</span><br><span class="line">	<span class="keyword">delete</span>[] t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line">	_swap(a, b);</span><br><span class="line">	cout&lt;&lt; a &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ⅱ重载函数的调用匹配规则"><a href="#Ⅱ重载函数的调用匹配规则" class="headerlink" title="Ⅱ重载函数的调用匹配规则"></a><strong>Ⅱ重载函数的调用匹配规则</strong></h4><p>为了估计哪个重载函数最适合，需要依次按照下列规则来判断：<br>遇见实参与形参不匹配的情况时，会自动进行转换</p>
<ul>
<li><strong>精确匹配</strong>：参数匹配而不做转换，或者只是做微不足道的转换，如数组名到指针、函数名到指向函数的指针；</li>
<li><strong>提升匹配</strong>：即整数提升（如bool 到 int、char到int、short 到int），float到double</li>
<li><strong>使用标准转换匹配</strong>：如int 到double、double到int、double到long double、Derived<em>到Base</em>、T<em>到void</em>、int到unsigned int；</li>
<li><strong>编译器傻了</strong>：如果在最高层有多个匹配函数找到，调用将被拒绝（因为有歧义、模凌两可）</li>
</ul>
<h4 id="Ⅲ函数重载遇上默认参数"><a href="#Ⅲ函数重载遇上默认参数" class="headerlink" title="Ⅲ函数重载遇上默认参数"></a>Ⅲ函数重载遇上默认参数</h4><p>在给重载函数指定默认参数时，要考虑是否会和别的重载函数冲突</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;fun(int a) &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">8</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;fun(int,int =8) &quot;</span> &lt;&lt; a &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//fun(5);	//error C2668: “fun”: 对重载函数的调用不明确</span></span><br><span class="line">	  <span class="built_in">fun</span>(<span class="number">5</span>, <span class="number">6</span>);<span class="comment">//正确</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14、C-中的类：string"><a href="#14、C-中的类：string" class="headerlink" title="14、C++中的类：string"></a>14、C++中的类：string</h2><p>需包含头文件：</p>
<blockquote>
<p>#include<string></p>
</blockquote>
<p><code>sts::string</code>类是C++提供的字符串类，可以很方便的去操作字符串</p>
<h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><h4 id="1-定义变量-string-变量名-xxxxxxxx"><a href="#1-定义变量-string-变量名-xxxxxxxx" class="headerlink" title="1.定义变量:string+变量名=&quot;xxxxxxxx&quot;"></a>1.定义变量:<code>string+变量名=&quot;xxxxxxxx&quot;</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">//注意：string也要在std中使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//定义字符串</span></span><br><span class="line">  string name = <span class="string">&quot;I&#x27;m aqua,what&#x27;s your name?&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-输出字符串："><a href="#2-输出字符串：" class="headerlink" title="2.输出字符串："></a>2.输出字符串：</h4><ul>
<li>cout         </li>
<li>printf：<code>printf(&quot;%s&quot;,变量名.c_str())或者printf(&quot;%s&quot;,变量名.data())</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出：</span></span><br><span class="line"> cout &lt;&lt; name &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure>

<h4 id="3-获取长度"><a href="#3-获取长度" class="headerlink" title="3.获取长度"></a>3.获取长度</h4><ul>
<li><code>变量名.length()</code></li>
<li><code>变量名.size()</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取长度</span></span><br><span class="line">  cout &lt;&lt; name.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; name.<span class="built_in">length</span>() &lt;&lt; endl;<span class="comment">//26   26</span></span><br></pre></td></tr></table></figure>

<h4 id="4-获取单个字符：变量名-at-字符位置"><a href="#4-获取单个字符：变量名-at-字符位置" class="headerlink" title="4.获取单个字符：变量名.at(字符位置)"></a>4.获取单个字符：<code>变量名.at(字符位置)</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; name.<span class="built_in">at</span>(<span class="number">0</span>) &lt;&lt; endl; <span class="comment">//I  注意计数是从0开始</span></span><br></pre></td></tr></table></figure>

<h4 id="5-遍历每个字符"><a href="#5-遍历每个字符" class="headerlink" title="5. 遍历每个字符"></a>5. 遍历每个字符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历每个字符</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; n : name)</span><br><span class="line"> &#123;</span><br><span class="line">  cout &lt;&lt;n&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="6-追加字符：变量名-push-bake-x"><a href="#6-追加字符：变量名-push-bake-x" class="headerlink" title="6.追加字符：变量名.push_bake(&#39;x&#39;)"></a>6.追加字符：<code>变量名.push_bake(&#39;x&#39;)</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//追加字符</span></span><br><span class="line"> name.<span class="built_in">push_back</span>(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line"> cout &lt;&lt; name &lt;&lt; endl;<span class="comment">//I&#x27;m aqua,what&#x27;s your name?h</span></span><br></pre></td></tr></table></figure>

<h4 id="7-追加字符串：变量名-append-xxx"><a href="#7-追加字符串：变量名-append-xxx" class="headerlink" title="7. 追加字符串：变量名.append(&quot;xxx&quot;)"></a>7. 追加字符串：<code>变量名.append(&quot;xxx&quot;)</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//追加字符串</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment">//name.append(&quot;hydro&quot;);    //I&#x27;m aqua,what&#x27;s your name?hhydro </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//name.append(10, &#x27;N&#x27;);   //在后面加上10个N  :I&#x27;m aqua,what&#x27;s your name?hNNNNNNNNNN</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//name.append(&quot;hydro,how are you?&quot;, 5); //追加前5个字符：I&#x27;m aqua,what&#x27;s your name?hhydro </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//name.append(&quot;123456789&quot;, 2, 4);       //从第2个字符开始往后取4个数：I&#x27;m aqua,what&#x27;s your name?h3456</span></span><br><span class="line">  cout &lt;&lt; name &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="8-插入：变量名-insert"><a href="#8-插入：变量名-insert" class="headerlink" title="8. 插入：变量名.insert()"></a>8. 插入：<code>变量名.insert()</code></h4><h4 id="9-替换：变量名-replace"><a href="#9-替换：变量名-replace" class="headerlink" title="9. 替换：变量名.replace()"></a>9. 替换：<code>变量名.replace()</code></h4><p>​           10. 删除：删除所有<code>变量名.erase()</code>  </p>
<p>​           11.查找：<code>变量名.find()</code></p>
<p>​           12.清空</p>
<p>​           13.直接使用运算符（C++独有的操作）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/10/26/%E4%BB%8Ec%E5%88%B0c++/" data-id="clo6qc91w0002dswae2jk9ave" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/10/26/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2023/10/25/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/10/26/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/10/26/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/10/26/%E4%BB%8Ec%E5%88%B0c++/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/10/25/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>